export default [
  {
    "statements": [
      "CREATE TABLE items (\n    value text NOT NULL,\n    CONSTRAINT items_pkey PRIMARY KEY (value)\n)",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'items', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_items_primarykey ON \"public\".\"items\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_items_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"value\" IS DISTINCT FROM NEW.\"value\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column value as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_items_primarykey\n  BEFORE UPDATE ON \"public\".\"items\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_items_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_items_into_oplog ON \"public\".\"items\";",
      "    CREATE OR REPLACE FUNCTION insert_public_items_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'items';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'items',\n            'INSERT',\n            json_strip_nulls(json_build_object('value', new.\"value\")),\n            jsonb_build_object('value', new.\"value\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_items_into_oplog\n  AFTER INSERT ON \"public\".\"items\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_items_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_items_into_oplog ON \"public\".\"items\";",
      "    CREATE OR REPLACE FUNCTION update_public_items_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'items';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'items',\n            'UPDATE',\n            json_strip_nulls(json_build_object('value', new.\"value\")),\n            jsonb_build_object('value', new.\"value\"),\n            jsonb_build_object('value', old.\"value\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_items_into_oplog\n  AFTER UPDATE ON \"public\".\"items\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_items_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_items_into_oplog ON \"public\".\"items\";",
      "    CREATE OR REPLACE FUNCTION delete_public_items_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'items';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'items',\n            'DELETE',\n            json_strip_nulls(json_build_object('value', old.\"value\")),\n            NULL,\n            jsonb_build_object('value', old.\"value\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_items_into_oplog\n  AFTER DELETE ON \"public\".\"items\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_items_into_oplog_function();"
    ],
    "version": "1"
  },
  {
    "statements": [
      "CREATE TABLE singly_linked_nodes (\n    uuid uuid NOT NULL,\n    next_node uuid,\n    CONSTRAINT singly_linked_nodes_pkey PRIMARY KEY (uuid),\n    CONSTRAINT singly_linked_nodes_next_node_fkey FOREIGN KEY (next_node) REFERENCES singly_linked_nodes(uuid)\n)",
      "CREATE TABLE doubly_linked_nodes (\n    uuid uuid NOT NULL,\n    next_node uuid,\n    prev_node uuid,\n    CONSTRAINT doubly_linked_nodes_pkey PRIMARY KEY (uuid),\n    CONSTRAINT doubly_linked_nodes_next_node_fkey FOREIGN KEY (next_node) REFERENCES doubly_linked_nodes(uuid),\n    CONSTRAINT doubly_linked_nodes_prev_node_fkey FOREIGN KEY (prev_node) REFERENCES doubly_linked_nodes(uuid)\n)",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'singly_linked_nodes', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_singly_linked_nodes_primarykey ON \"public\".\"singly_linked_nodes\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_singly_linked_nodes_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"uuid\" IS DISTINCT FROM NEW.\"uuid\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column uuid as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_singly_linked_nodes_primarykey\n  BEFORE UPDATE ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_singly_linked_nodes_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_singly_linked_nodes_into_oplog ON \"public\".\"singly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION insert_public_singly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'singly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'singly_linked_nodes',\n            'INSERT',\n            json_strip_nulls(json_build_object('uuid', new.\"uuid\")),\n            jsonb_build_object('next_node', new.\"next_node\", 'uuid', new.\"uuid\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_singly_linked_nodes_into_oplog\n  AFTER INSERT ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_singly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_singly_linked_nodes_into_oplog ON \"public\".\"singly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION update_public_singly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'singly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'singly_linked_nodes',\n            'UPDATE',\n            json_strip_nulls(json_build_object('uuid', new.\"uuid\")),\n            jsonb_build_object('next_node', new.\"next_node\", 'uuid', new.\"uuid\"),\n            jsonb_build_object('next_node', old.\"next_node\", 'uuid', old.\"uuid\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_singly_linked_nodes_into_oplog\n  AFTER UPDATE ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_singly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_singly_linked_nodes_into_oplog ON \"public\".\"singly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION delete_public_singly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'singly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'singly_linked_nodes',\n            'DELETE',\n            json_strip_nulls(json_build_object('uuid', old.\"uuid\")),\n            NULL,\n            jsonb_build_object('next_node', old.\"next_node\", 'uuid', old.\"uuid\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_singly_linked_nodes_into_oplog\n  AFTER DELETE ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_singly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_singly_linked_nodes_next_node_into_oplog ON \"public\".\"singly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_singly_linked_nodes_next_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'singly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'singly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"singly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"next_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_singly_linked_nodes_next_node_into_oplog\n  AFTER INSERT ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_singly_linked_nodes_next_node_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_singly_linked_nodes_next_node_into_oplog ON \"public\".\"singly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_singly_linked_nodes_next_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'singly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'singly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"singly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"next_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_singly_linked_nodes_next_node_into_oplog\n  AFTER UPDATE ON \"public\".\"singly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_singly_linked_nodes_next_node_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'doubly_linked_nodes', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_doubly_linked_nodes_primarykey ON \"public\".\"doubly_linked_nodes\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_doubly_linked_nodes_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"uuid\" IS DISTINCT FROM NEW.\"uuid\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column uuid as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_doubly_linked_nodes_primarykey\n  BEFORE UPDATE ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_doubly_linked_nodes_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_doubly_linked_nodes_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION insert_public_doubly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'doubly_linked_nodes',\n            'INSERT',\n            json_strip_nulls(json_build_object('uuid', new.\"uuid\")),\n            jsonb_build_object('next_node', new.\"next_node\", 'prev_node', new.\"prev_node\", 'uuid', new.\"uuid\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_doubly_linked_nodes_into_oplog\n  AFTER INSERT ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_doubly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_doubly_linked_nodes_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION update_public_doubly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'doubly_linked_nodes',\n            'UPDATE',\n            json_strip_nulls(json_build_object('uuid', new.\"uuid\")),\n            jsonb_build_object('next_node', new.\"next_node\", 'prev_node', new.\"prev_node\", 'uuid', new.\"uuid\"),\n            jsonb_build_object('next_node', old.\"next_node\", 'prev_node', old.\"prev_node\", 'uuid', old.\"uuid\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_doubly_linked_nodes_into_oplog\n  AFTER UPDATE ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_doubly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_doubly_linked_nodes_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION delete_public_doubly_linked_nodes_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'doubly_linked_nodes',\n            'DELETE',\n            json_strip_nulls(json_build_object('uuid', old.\"uuid\")),\n            NULL,\n            jsonb_build_object('next_node', old.\"next_node\", 'prev_node', old.\"prev_node\", 'uuid', old.\"uuid\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_doubly_linked_nodes_into_oplog\n  AFTER DELETE ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_doubly_linked_nodes_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_doubly_linked_nodes_next_node_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_doubly_linked_nodes_next_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'doubly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"doubly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"next_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_doubly_linked_nodes_next_node_into_oplog\n  AFTER INSERT ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_doubly_linked_nodes_next_node_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_doubly_linked_nodes_next_node_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_doubly_linked_nodes_next_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'doubly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"doubly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"next_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_doubly_linked_nodes_next_node_into_oplog\n  AFTER UPDATE ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_doubly_linked_nodes_next_node_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_doubly_linked_nodes_prev_node_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_doubly_linked_nodes_prev_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'doubly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"doubly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"prev_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_doubly_linked_nodes_prev_node_into_oplog\n  AFTER INSERT ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_doubly_linked_nodes_prev_node_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_doubly_linked_nodes_prev_node_into_oplog ON \"public\".\"doubly_linked_nodes\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_doubly_linked_nodes_prev_node_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'doubly_linked_nodes';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'doubly_linked_nodes',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('uuid', \"uuid\"))),\n            jsonb_build_object('uuid', \"uuid\"),\n            NULL,\n            NULL\n          FROM \"public\".\"doubly_linked_nodes\"\n          WHERE \"uuid\" = NEW.\"prev_node\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_doubly_linked_nodes_prev_node_into_oplog\n  AFTER UPDATE ON \"public\".\"doubly_linked_nodes\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_doubly_linked_nodes_prev_node_into_oplog_function();"
    ],
    "version": "2"
  }
]